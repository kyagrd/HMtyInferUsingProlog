The purpose of this docuement is basically a TODO list for revision.
Will be crossing out the contents of already revised things.
Reveiw contents that are irrelavant will be corssed out as well.


----------------------- REVIEW 1 ---------------------

Opinion
=======

Unfortunately, the section 3.3 discussing the extension to nested
data types and polymorphic recursion is written in a very compact
style and some constructs lack an introduction,
which makes it hard to understand.

Moreover, the use of Prolog to implement inference systems
is natural and, thus, well known for a long time (e.g.,
compare Typol and similar approaches from the 90s) so that
the current approach is not quite innovative.
The authors should definitively compare their work to these
and other approaches to specify type systems, e.g., higher-order
logic systems like lambda-Prolog or LF (or Twelf, see
http://twelf.org/wiki/Lily).

Comments
========

Figure 4 also contains auxiliary functions unfold_N_ap whose purpose is left
open. I therefore suggest to extend the explanation of the implementation
presented in Figure 4. To get along with the supplied space, I furthermore
suggest to reduce or even omit the Figure 5, since in my perception it did
not provide as much insights as a more detailed explanation of Figure 4 would
have done.

Typos, Style
============

- Please consider adding line numbers to your submissions, as it facilitates
  the exchange of typos and alike for both you and me!

- Figure 4: `in(N,E)` was not explained

----------------------- REVIEW 2 ---------------------

The main complication that arises is that there is need to delay some of
the goals, and create a staged algorithm. For example, during type checking,
constraints on kinds are collected, which need to be solved separately in
a later stage.
Not being a Prolog expert myself, I can't help but feel that the approach to
solving this feels somewhat fragile and hacky, destroying the simplicity
the approach otherwise sets out to convey.

It is conceivable (but also somewhat unsurprising) that with a bit of practice,
Prolog is a viable specification language for such type systems. What seems a
bit sad is that there seems to be no way to generate the Prolog specification
out of a yet more declarative system, or alternatively to transfer the Prolog
implementation into other programming languages, which makes me believe that
more specialized tools like e.g. Ott (by Sewell et al, ICFP 2007) may be more
useful in practice. Sadly, no comparison with Ott is given, although the more
general comparison with Coq applies to some extent.

OTHER COMMENTS:

P2: "capturing both type checking and type inference without duplication"
This seems compelling at first, but for more complicated systems, where
efficient inference can be significantly more complex as checking, does
it not mean that we have to expect a more complex specification than
necessary for pure type checking?

----------------------- REVIEW 3 ---------------------

It would be nice to have a clearer discussion on how these ideas can be used
in the LP/FP communities, and the paper sometimes assumes the reader knows
the details of the Haskell type system.

Some comments:

- the paper would be stronger if it could clarify at the beginning the extent to
which it covers a full FP implementation (and there are several to choose from).

- The Fig 1 program is really critical to the paper, so it should start by
precisely defining what it does: type an expression E, given a typing context C.
Maybe you could add a short pldoc style comment to Fig 1 in order to do that?

- With fully functioning basic building blocks for kind inference (kind) and
type inference (type), should be .... -> It would be nice if you could have
a stronger argument here.

- Last, there is a clear application of your system as a pedagogical tool, but
is that it? Also, it would be nice to have a broad perspective on the state of
typing in Haskell and ML, and how far you think you are?

- Weird question: what about modules?

