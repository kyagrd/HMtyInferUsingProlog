\section{Related Work}\label{sec:relwork}
The idea of using logic programming to specify type inference is not new.
\citet*{HMX99} defined a general framework called \HMX\ for specifying
extensions of HM (e.g., records, type classes, intersection types)
and \citet{tyinferCHR02} implemented \HMX\ using Prolog with
constraint handling rules (CHR). Testing a type system extension
in the \HMX\ framework provides a certain level of confidence that the extension
would work well with type polymorphism in HM. Testing an extension by
extending our specification provides additional confidence that the extension
would work well with type constructor polymorphism and kind polymorphism,
as well as with type polymorphism.

The concept of delayed goals have been used in many different contexts
in logic programming. An AILog\footnote{A logical inference system for designing
	 intelligent agents.} textbook \cite{AILogTextBook},
introduces delaying goals as one of the useful abilities of meta-interpreter.
Many Prolog systems, such as SWI or SICStus, provide built-in support for
delaying a goal until a certiain conditions are met using the predicates
such as \verb|freeze| or \verb|when|. In our specification supporting
type constructor polymorphism and kind polymorphism, we could not
simply use \verb|freeze| or \verb|when| because we pre-process
the collected delayed goals (see \verb|variableze| in \S\ref{ssec:HMtck}).

%% delayed goals are not uncommon in logic programming
%% http://artint.info/html/ArtInt_329.html
%% 
%% https://books.google.com/books?id=Q4i5edW7IyQC&pg=PA321&lpg=PA321
%%
%% https://books.google.com/books?id=d2_i0qeP6yUC&pg=PA645&lpg=PA645

There are experimental Prolog implementations that support peculiar features
such as
$\lambda$Prolog \cite{nadathur99cade}
supporting (restricted version of) higher-order unification
and 
$\alpha$Prolog \cite{cheney04iclp}
supporting nominal abstraction in a purely logical setting.
Such features may help us specify universal quantifications and fresh name
generations more elegantly, but there is a trade-off for not having the
pragmatic support (e.g. built-ins for extra-logical features, documentation, and
graphical debugging) of more widely-used and well-maintained systems
such as SWI or SICStus.

Recently, there has been research on type inference using logic programming
with non-standard semantics (e.g., corecursive, coinductive, or coalgebraic)
for object-oriented languages (e.g., featherweight Java) but
functional languages were left for future work \cite{AnconaLZ08}.

