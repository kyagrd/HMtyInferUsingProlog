\section{Related Work}\label{sec:relwork}
The idea of using logic programming to specify type inference is not new.
\citet*{HMX99} defined a general framework called \HMX\ for specifying
extensions of HM (e.g., records, type classes, intersection types)
and \citet{tyinferCHR02} implemented \HMX\ using Prolog with
constraint handling rules (CHR). Testing a type system extension
in the \HMX\ framework provides a certain level of confidence that the extension
would work well with type polymorphism in HM. Testing an extension by
extending our specification provides additional confidence that the extension
would work well with type constructor polymorphism and kind polymorphism,
as well as with type polymorphism.

\subsection{Delayed Goals and Control Flow in Logic Programming}
The concept of delayed goals have been used in many different contexts
in logic programming. An AILog\footnote{A logical inference system for designing
	 intelligent agents.} textbook \cite{AILogTextBook},
introduces delaying goals as one of the useful abilities of meta-interpreter.
Many Prolog systems, such as SWI or SICStus, provide built-in support for
delaying a goal until certain conditions are met using the predicates
such as \verb|freeze| or \verb|when|. In our specification supporting
type constructor polymorphism and kind polymorphism, we could not
simply use \verb|freeze| or \verb|when| because we pre-process
the collected delayed goals (see \verb|variableze| in \S\ref{ssec:HMtck}).
Recently, \citet{SchDemDesWei13} implemented delimited continutations for Prolog,
which might be a usful abstraction useful for describing delayed goals used in
our current specification.

\subsection{Other Logic Programming systems}
There are experimental Prolog implementations that support peculiar features
such as \aProlog\ \cite{cheney04iclp} supporting nominal abstraction in a purely
logical setting and \lProlog\ \cite{nadathur99cade} supporting (restricted
version of) higher-order unification. Such features may help us specify universal
quantifications and fresh name generations more elegantly, but there is a
trade-off for not having the pragmatic support (e.g. built-ins for extra-logical
features, documentation, and graphical debugging) of more widely-used and
well-maintained systems such as SWI or SICStus. In fact, the developer of
\aProlog\ attempted to implement of HM type inference in \aProlog, which
intended to implement a single directional type inference rather than 
a bidirectional relation that could also be used for type checking like
our specification, but failed to produce a working version.\footnote{
	See \texttt{miniml.apl} in the examples directory of
	the \aProlog\ distribution (provided in both 0.3 and 0.4 versions). }
\TODO{\lProlog\ story. There are two things to talk about.
	One is the type inference implementation in the pcf example
	distributed with the \lProlog\ implementation.
	Another one is \url{http://lpcic.gforge.inria.fr/index.html} }.



Recently, there has been research on type inference using logic programming
with non-standard semantics (e.g., corecursive, coinductive, or coalgebraic)
for object-oriented languages (e.g., featherweight Java) but
functional languages were left for future work \cite{AL-ECOOP09}.


\subsection{Descriptions of Type Inference Algorithms in ITPs}
There are several formal descriptions of type inference algorithms using
Interactive Theorem Prover(ITP)s such as
Agda [TODO] and Isabelle/HOL [TODO].
\TODO{cite the papers regarding Agda and Nominal Isabelle}
The primoary motivation in such line of work is to formally prove
theoretical properties (e.g., soundness, principal typing) of a
type inference algorithm, which is differeent from our motivation of
providing a human readable \& machine executable specificiation for
the algorithm to reduce the gap between theoretical specification and
practical implementation. Describing type inference algorhthms ITPs
are challenging for two reasons. First, fresh name geneartion should
be monitored more explicitly and rigourously in order to provide proper
information for the properties to be formally proven. Second, the algorithm
must be massaged into a from to convince the termination checker of the ITP.
As a result, those descriptions tend to divert from the usual desription of
the algorithm, which is not a relational specification to start with.

